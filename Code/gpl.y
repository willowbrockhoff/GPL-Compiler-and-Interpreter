// Mon Apr 27 16:03:16 PDT 2020
// bison syntax indicating C++ declarations required by both the parser and scanner
%code requires {
  #include <string>
  class Expression;
  class Variable;
  class Statement;
  class NullStatement;
  class Locator;
  struct Node;
  #ifndef P1
  #include "types_and_ops.h"  //include in all projects except the first
  #endif
  #ifdef GRAPHICS
    #include "Window.h"
  #endif
}

// bison syntax to indicate the beginning of a C/C++ code section
%{

extern int yylex();  // prototype of function generated by flex
extern int yyerror(const char *); // used to print errors
extern int line_count;            // current line in the input; from record.l

#include "error.h"      // class for printing errors (used by gpl)
#include <iostream>

#include "Scope_manager.h"
#include "Symbol.h"
#include "Symbol_table.h"
#include "Event_manager.h"
#include "Constant.h"
#include "Statement.h"
#include "Variable.h"
#include "Game_object.h"
#include "Window.h"
#include "Locator.h"
Scope_manager sm;
extern Event_manager em;

struct Node {
        std::string name;
        const Expression* value;
        Node* next;


        Node(std::string node_name, const Expression* node_value) :
          name(node_name), value(node_value), next(nullptr) {}
};

Node* head = nullptr;
Node* tail = nullptr;


template<typename OP, gamelang::Operator optype>
    const Expression* Bin_op_check(const Expression* one, const Expression* three, unsigned int valid_types)
    {
    assert(one);
    assert(three);
      using namespace gamelang;
      bool lht_valid=one->type() & valid_types;
      bool rht_valid=three->type() & valid_types;
      if(lht_valid && rht_valid) return new OP(one, three); 
      if(!lht_valid) { error(INVALID_LEFT_OPERAND_TYPE, to_string(optype)); }
      if(!rht_valid) { error(INVALID_RIGHT_OPERAND_TYPE, to_string(optype)); }
      delete one; delete three;
      return new Integer_constant(0);
    }

    template<typename OP, gamelang::Operator optype>
    const Expression* Uni_op_check(const Expression* two, unsigned int valid_types)
    {
      using namespace gamelang;
      bool op_valid=two->type() & valid_types;
      if(op_valid) return new OP(two); 
      if(!op_valid) { error(INVALID_RIGHT_OPERAND_TYPE, to_string(optype)); }
      delete two;
      return new Integer_constant(0);
    }
// bison syntax indicating the end of a C/C++ code section
%} 
%left T_OR
%left T_AND
%left T_EQUAL T_NOT_EQUAL
%left T_LESS_EQUAL T_GREATER_EQUAL T_LESS T_GREATER
%left T_PLUS T_MINUS
%left T_MULTIPLY T_DIVIDE T_MOD
%right T_NOT NEGATION
%nonassoc T_NEAR T_TOUCHES
%nonassoc IF_NO_ELSE
%nonassoc T_ELSE

// turn on verbose (longer) error messages
%define parse.error verbose

%union {
 int            union_int;
 std::string*   union_string;  
 double         union_double;
 gamelang::Type union_gpl_type;
 const Expression* union_expression_ptr;
 Variable* union_variable_ptr;
 Node* union_node;
 Statement* union_statement_ptr;

 Window::Keystroke union_keystroke_ptr;
 
 
};

// tokens declared here

 /* updated January 2019
  * Copy the following token declarations into your .y file. */

 /* Tokens with angle braces < > after %token require a type.
  * This is the type of the variable the scanner (flex) puts into the union.
  * Fill in the < > with the appropriate union variable
  *     for example
  *     %token <union_int> T_INT_CONSTANT       "int constant"
  */

%token T_INT                 "int"
%token T_DOUBLE              "double"
%token T_STRING              "string"
%token T_TRIANGLE            "triangle"
%token T_PIXMAP              "pixmap"
%token T_CIRCLE              "circle"
%token T_RECTANGLE           "rectangle"
%token T_TEXTBOX             "textbox"

%token T_FORWARD             "forward"
%token T_INITIALIZATION      "initialization"
%token T_TERMINATION         "termination"
%token T_ON                  "on"
%token T_ANIMATION           "animation"
%token T_IF                  "if"
%token T_FOR                 "for"
%token T_ELSE                "else"
%token <union_int> T_EXIT            "exit"  /* value is line number */
%token <union_int> T_PRINT           "print" /* value is line number */
%token T_TRUE                "true"
%token T_FALSE               "false"

%token T_SPACE               "space"
%token T_LEFTARROW           "leftarrow"
%token T_RIGHTARROW          "rightarrow"
%token T_UPARROW             "uparrow"
%token T_DOWNARROW           "downarrow"
%token T_LEFTMOUSE_DOWN      "leftmouse_down"
%token T_MIDDLEMOUSE_DOWN    "middlemouse_down"
%token T_RIGHTMOUSE_DOWN     "rightmouse_down"
%token T_LEFTMOUSE_UP        "leftmouse_up"
%token T_MIDDLEMOUSE_UP      "middlemouse_up"
%token T_RIGHTMOUSE_UP       "rightmouse_up"
%token T_MOUSE_MOVE          "mouse_move"
%token T_MOUSE_DRAG          "mouse_drag"
%token T_F1                  "f1"
%token T_AKEY                "akey"
%token T_SKEY                "skey"
%token T_DKEY                "dkey"
%token T_FKEY                "fkey"
%token T_HKEY                "hkey"
%token T_JKEY                "jkey"
%token T_KKEY                "kkey"
%token T_LKEY                "lkey"
%token T_WKEY                "wkey"
%token T_ZKEY                "zkey"

%token T_LPAREN              "("
%token T_RPAREN              ")"
%token T_LBRACE              "{"
%token T_RBRACE              "}"
%token T_LBRACKET            "["
%token T_RBRACKET            "]"
%token T_SEMIC               ";"
%token T_COMMA               ","
%token T_PERIOD              "."

%token T_ASSIGN              "="
%token T_PLUS_ASSIGN         "+="
%token T_MINUS_ASSIGN        "-="
%token T_PLUS_PLUS           "++"
%token T_MINUS_MINUS         "--"

%token T_SIN                 "sin"
%token T_COS                 "cos"
%token T_TAN                 "tan"
%token T_ASIN                "asin"
%token T_ACOS                "acos"
%token T_ATAN                "atan"
%token T_SQRT                "sqrt"
%token T_ABS                 "abs"
%token T_FLOOR               "floor"
%token T_RANDOM              "random"

%token T_TOUCHES             "touches"
%token T_NEAR                "near"

%token T_MULTIPLY            "*"
%token T_DIVIDE              "/"
%token T_PLUS                "+"
%token T_MINUS               "-"
%token T_MOD                 "%"
%token T_LESS                "<"
%token T_GREATER             ">"
%token T_LESS_EQUAL          "<="
%token T_GREATER_EQUAL       ">="
%token T_EQUAL               "=="
%token T_NOT_EQUAL           "!="
%token T_NOT                 "!"
%token T_AND                 "&&"
%token T_OR                  "||"

%token <union_int> T_INT_CONSTANT    "int constant"
%token <union_double> T_DOUBLE_CONSTANT "double constant"
%token <union_string> T_STRING_CONSTANT "string constant"
%token <union_string> T_ID                  "identifier"
%type <union_gpl_type> simple_type
%type <union_expression_ptr> expression
%type <union_expression_ptr> primary_expression
%type <union_expression_ptr> optional_initializer
%type <union_variable_ptr> variable
%type <union_node> parameter
%type <union_node> parameter_list
%type <union_node> parameter_list_or_empty
%type <union_statement_ptr> statement_list
%type <union_statement_ptr> statement_or_block_of_statements
%type <union_statement_ptr> assign_statement_or_empty
%type <union_statement_ptr> statement
%type <union_statement_ptr> print_statement
%type <union_statement_ptr> for_statement
%type <union_statement_ptr> statement_block
%type <union_statement_ptr> assign_statement
%type <union_statement_ptr> exit_statement
%type <union_statement_ptr> if_statement
%type <union_keystroke_ptr> keystroke



//////////////////////////////////////////////////////////////////////////////////////
%type <union_gpl_type> object_type
//%type <Node> parameter 
/////////////////////////////////////////////////////////////////////////////////////


%destructor { delete $$; } <union_string>


 /* special token that does not match any production */
 /* used for characters that are not part of the language */
%token T_ERROR               "error"




%%

// updated October 2021

//---------------------------------------------------------------------
program:
    declaration_list block_list


//---------------------------------------------------------------------
declaration_list:
    declaration_list declaration
    | %empty


//---------------------------------------------------------------------
declaration:
    variable_declaration T_SEMIC
    | object_declaration T_SEMIC
    | forward_declaration T_SEMIC


//---------------------------------------------------------------------
variable_declaration:

  simple_type  T_ID  optional_initializer{
      std::unique_ptr<std::string> d2($2);
      std::unique_ptr<const Expression> opt($3);
      if(sm.defined_in_current_scope(*d2)) {
        gamelang::error(gamelang::PREVIOUSLY_DECLARED_VARIABLE, *d2);
        break;
      }

      try {

        std::unique_ptr<const Constant> stiant(opt ? opt->evaluate() : nullptr);
        switch($1) {
          case gamelang::INT:
            sm.add_to_current_scope(new Symbol(*d2, new int(stiant ? stiant->as_int() : 0)));
            break;
          case gamelang::DOUBLE:
          
            sm.add_to_current_scope(new Symbol(*d2, new double(stiant ? stiant->as_double() : 0.0)));
            break;
          case gamelang::STRING: //NOT HERE
            sm.add_to_current_scope(new Symbol(*d2, new std::string(stiant ? stiant->as_string() : "")));
            break;         
          default: assert(false);
        }
      } catch(gamelang::Type tt) {
         
          gamelang::error(gamelang::INVALID_TYPE_FOR_INITIAL_VALUE,
          gamelang::to_string(tt), *d2,
          gamelang::to_string($1));
          switch($1) {
          case gamelang::INT:
            sm.add_to_current_scope(new Symbol(*d2, new int(0)));
            break;
          case gamelang::DOUBLE:
            sm.add_to_current_scope(new Symbol(*d2, new double(0.0)));
            break;
          case gamelang::STRING: //NOT HERE
            sm.add_to_current_scope(new Symbol(*d2, new std::string("")));
            break;
          default: assert(false);
        }
      }
    }
    
    | simple_type  T_ID T_LBRACKET expression T_RBRACKET{
      std::unique_ptr<std::string> d2($2);
      std::unique_ptr<const Expression> d4($4);
      std::unique_ptr<const Constant> items(d4->evaluate());
      int num_items;
      try { num_items=items->as_int(); }
      catch(gamelang::Type bad_type) {
        gamelang::error(gamelang::ARRAY_SIZE_MUST_BE_AN_INTEGER, gamelang::to_string(bad_type), *d2);
        num_items=1;
      }
      if(num_items<1) {
        gamelang::error(gamelang::INVALID_ARRAY_SIZE, *d2, std::to_string(num_items));
        num_items=1;
      }
      if(sm.defined_in_current_scope(*d2)) {
        gamelang::error(gamelang::PREVIOUSLY_DECLARED_VARIABLE, *d2);
        break;
      }

      Symbol* sym;
      switch($1)
      {
        case gamelang::INT: {
          int* ptr=new int[num_items];
          for(int i=0; i<num_items; ++i)
            ptr[i]= 0;
          sym=new Symbol(*d2, ptr, num_items);
          break;
        }
        case gamelang::DOUBLE: {
          double* ptr=new double[num_items];
          for(int i=0; i<num_items; ++i)
            ptr[i]= 0.0;
          sym=new Symbol(*d2, ptr, num_items);
          break;
        }
        case gamelang::STRING: {
          std::string* ptr=new std::string[num_items];
          for(int i=0; i<num_items; ++i)
            ptr[i]= "";
          sym=new Symbol(*d2, ptr, num_items);
          break;
        }
        default: assert(false);
      }
      sm.add_to_current_scope(sym);
    }
    


//---------------------------------------------------------------------
simple_type:
    T_INT       {$$=gamelang::INT;}
    | T_DOUBLE  {$$=gamelang::DOUBLE;}
    | T_STRING  {$$=gamelang::STRING;}


//---------------------------------------------------------------------
optional_initializer:
    T_ASSIGN expression {$$=$2;}
    | %empty {$$=nullptr;}


//---------------------------------------------------------------------
object_declaration:
    object_type T_ID parameter_list_or_empty{
      
      Game_object* gop;
      Circle* cir_ptr = nullptr;
      Rectangle* rec_ptr = nullptr;
      Triangle* tri_ptr = nullptr;
      Pixmap* pix_ptr = nullptr;
      Textbox* txt_ptr = nullptr;

      std::unique_ptr<std::string> id($2);
      if(sm.defined_in_current_scope(*id)) {
        gamelang::error(gamelang::PREVIOUSLY_DECLARED_VARIABLE, *id);
        break;
      }
      switch($1) {
        case gamelang::CIRCLE:
          cir_ptr = new Circle;
          gop = cir_ptr;
          sm.add_to_current_scope(new Symbol(*id, cir_ptr));
          break;
        case gamelang::RECTANGLE:
          rec_ptr = new Rectangle;
          gop = rec_ptr;
          sm.add_to_current_scope(new Symbol(*id, rec_ptr));
          break;
        case gamelang::TRIANGLE:
          tri_ptr = new Triangle;
          gop = tri_ptr;
          sm.add_to_current_scope(new Symbol(*id, tri_ptr));
          break;
        case gamelang::PIXMAP:
          pix_ptr = new Pixmap;
          gop = pix_ptr;
          sm.add_to_current_scope(new Symbol(*id, pix_ptr));
          break;
        case gamelang::TEXTBOX:
          txt_ptr = new Textbox;
          gop = txt_ptr;
          sm.add_to_current_scope(new Symbol(*id, txt_ptr));
          break;
        default: assert(false);
      }
    

    Node* current_node = $3;
    while(current_node != nullptr){
      try{
        gamelang::Type attribute_type = gop->attribute_type(current_node->name);
      
        switch(attribute_type){
          case gamelang::INT: {
            const Constant* value = current_node->value->evaluate();
            int val = value->as_int();
            gop->write_attribute(current_node->name, val);
            break;
          }
          case gamelang::DOUBLE: {
            const Constant* value = current_node->value->evaluate();
            double val = value->as_double();
            gop->write_attribute(current_node->name, val);
            break;
          }
          case gamelang::STRING: {
            const Constant* value = current_node->value->evaluate();
            std::string val = value->as_string();
            gop->write_attribute(current_node->name, val);
            break;
          }
          default: assert(false);
        }
      }catch(const std::out_of_range&){

        gamelang::error(gamelang::UNKNOWN_CONSTRUCTOR_PARAMETER, *id, current_node->name);
      
      }/*catch(const gamelang::Type&){
        
        gamelang::error(gamelang::INCORRECT_CONSTRUCTOR_PARAMETER_TYPE, *id, current_node->name);
      
      }*/
      current_node = current_node->next;
    }

    

    }
    | object_type T_ID T_LBRACKET expression T_RBRACKET{

      std::unique_ptr<std::string> d2($2);
      std::unique_ptr<const Expression> d4($4);
      std::unique_ptr<const Constant> items(d4->evaluate());
      int num_items;
      try { num_items=items->as_int(); }
      catch(gamelang::Type bad_type) {
        gamelang::error(gamelang::ARRAY_SIZE_MUST_BE_AN_INTEGER, gamelang::to_string(bad_type), *d2);
        num_items=1;
      }
      if(num_items<1) {
        gamelang::error(gamelang::INVALID_ARRAY_SIZE, *d2, std::to_string(num_items));
        num_items=1;
      }
      if(sm.defined_in_current_scope(*d2)) {
        gamelang::error(gamelang::PREVIOUSLY_DECLARED_VARIABLE, *d2);
        break;
      }
      Symbol* sym;
        switch($1)
        {
          case gamelang::CIRCLE: {
            Circle* ptr=new Circle[num_items];
            sym=new Symbol(*d2, ptr, num_items);
            break;
          }
          case gamelang::RECTANGLE: {
            Rectangle* ptr=new Rectangle[num_items];
            sym=new Symbol(*d2, ptr, num_items);
            break;
          }
          case gamelang::TRIANGLE: {
            Triangle* ptr=new Triangle[num_items];
            sym=new Symbol(*d2, ptr, num_items);
            break;
          }
          case gamelang::PIXMAP: {
            Pixmap* ptr=new Pixmap[num_items];
            sym=new Symbol(*d2, ptr, num_items);
            break;
          }
          case gamelang::TEXTBOX: {
            Textbox* ptr=new Textbox[num_items];
            sym=new Symbol(*d2, ptr, num_items);
            break;
          }
          default: assert(false);
        }
        sm.add_to_current_scope(sym);



    }


//---------------------------------------------------------------------
object_type:
    T_TRIANGLE {$$=gamelang::TRIANGLE;}
    | T_PIXMAP {$$=gamelang::PIXMAP;}
    | T_CIRCLE {$$=gamelang::CIRCLE;}
    | T_RECTANGLE {$$=gamelang::RECTANGLE;}
    | T_TEXTBOX {$$=gamelang::TEXTBOX;}


//---------------------------------------------------------------------
parameter_list_or_empty :
    T_LPAREN parameter_list T_RPAREN { $$ = head; }
    | T_LPAREN T_RPAREN { $$ = nullptr; }
    | %empty  { $$ = nullptr; }


//---------------------------------------------------------------------
parameter_list :
    parameter_list T_COMMA parameter{
      if(head == nullptr){
        head = $3;
        tail = $3;
      }else{
        tail->next = $3;
        tail = $3;
      }
      $1 = head;
    }
    | parameter{
      head = $1;
      tail = $1;
    }


//---------------------------------------------------------------------
parameter:
    T_ID T_ASSIGN expression{
      $$ = new Node(*$1, $3);
    }


//---------------------------------------------------------------------
block_list:
    block_list block
    | %empty


//---------------------------------------------------------------------
block:
    initialization_block
    | termination_block
    | animation_block
    | on_block


//---------------------------------------------------------------------
initialization_block:
    T_INITIALIZATION statement_block


//---------------------------------------------------------------------
termination_block:
    T_TERMINATION statement_block


//---------------------------------------------------------------------
forward_declaration:
    T_FORWARD T_ANIMATION T_ID T_LPAREN animation_parameter T_RPAREN


//---------------------------------------------------------------------
animation_parameter:
    object_type T_ID
    | object_type


//---------------------------------------------------------------------
animation_block:
    animation_declaration statement_block


//---------------------------------------------------------------------
animation_declaration:
    T_ANIMATION T_ID T_LPAREN object_type T_ID T_RPAREN


//---------------------------------------------------------------------
on_block:
    T_ON keystroke statement_block { em.add_handler($2,$3);}
     //add this block as an event that can be executed. takes us to event manager


//---------------------------------------------------------------------
keystroke:
    T_SPACE               { $$ = Window::SPACE; }
    | T_UPARROW            { $$ = Window::UPARROW; }
    | T_DOWNARROW         { $$ = Window::DOWNARROW; }
    | T_LEFTARROW         { $$ = Window::LEFTARROW; }
    | T_RIGHTARROW        { $$ = Window::RIGHTARROW; }
    | T_LEFTMOUSE_DOWN    { $$ = Window::LEFTMOUSE_DOWN; }
    | T_MIDDLEMOUSE_DOWN  { $$ = Window::MIDDLEMOUSE_DOWN; }
    | T_RIGHTMOUSE_DOWN   { $$ = Window::RIGHTMOUSE_DOWN; }
    | T_LEFTMOUSE_UP      { $$ = Window::LEFTMOUSE_UP; }
    | T_MIDDLEMOUSE_UP    { $$ = Window::MIDDLEMOUSE_UP; }
    | T_RIGHTMOUSE_UP     { $$ = Window::RIGHTMOUSE_UP; }
    | T_MOUSE_MOVE        { $$ = Window::MOUSE_MOVE; }
    | T_MOUSE_DRAG        { $$ = Window::MOUSE_DRAG; }
    | T_AKEY              { $$ = Window::AKEY; }
    | T_SKEY              { $$ = Window::SKEY;}
    | T_DKEY              { $$ = Window::DKEY; }
    | T_FKEY              { $$ = Window::FKEY; }
    | T_HKEY              { $$ = Window::HKEY; }
    | T_JKEY              { $$ = Window::JKEY; }
    | T_KKEY              { $$ = Window::KKEY; }
    | T_LKEY              { $$ = Window::LKEY; }
    | T_WKEY              { $$ = Window::WKEY; }
    | T_ZKEY              { $$ = Window::ZKEY; }
    | T_F1                { $$ = Window::F1; }


//---------------------------------------------------------------------
statement_or_block_of_statements:
    statement_block
    | statement


//---------------------------------------------------------------------
statement_block:
    T_LBRACE statement_list T_RBRACE { $$ = $2; }
    | T_LBRACE T_RBRACE { $$ = new NullStatement;}



//---------------------------------------------------------------------
statement_list:
    //incorp next pointer and build list of stmts
    statement_list statement { $1->append_statement($2); $$=$1; }
    | statement { $$=$1; }


//---------------------------------------------------------------------
statement:
    if_statement 
    | for_statement
    | assign_statement T_SEMIC
    | print_statement T_SEMIC
    | exit_statement T_SEMIC


//---------------------------------------------------------------------
if_statement:
    T_IF T_LPAREN expression T_RPAREN statement_or_block_of_statements %prec IF_NO_ELSE {
      if($3->type() == gamelang::STRING || $3->type() == gamelang::DOUBLE || $3->type() == gamelang::CIRCLE || $3->type() == gamelang::RECTANGLE || 
         $3->type() == gamelang::PIXMAP){ gamelang::error(gamelang::INVALID_TYPE_FOR_IF_STMT_EXPRESSION); }
      $$ = new If($3, $5);
    }
    | T_IF T_LPAREN expression T_RPAREN statement_or_block_of_statements T_ELSE statement_or_block_of_statements {
      if($3->type() == gamelang::STRING || $3->type() == gamelang::DOUBLE || $3->type() == gamelang::CIRCLE || $3->type() == gamelang::RECTANGLE || 
         $3->type() == gamelang::PIXMAP){ gamelang::error(gamelang::INVALID_TYPE_FOR_IF_STMT_EXPRESSION); }
      $$ = new If($3, $5, $7);
    }


//---------------------------------------------------------------------
for_statement:
    T_FOR T_LPAREN assign_statement_or_empty T_SEMIC expression T_SEMIC assign_statement_or_empty T_RPAREN statement_or_block_of_statements{
      
      Statement* initalizer = $3 ? $3 : new NullStatement();
      Statement* incrementor = $7 ? $7 : new NullStatement();
      

      if($5->type() == gamelang::STRING || $5->type() == gamelang::DOUBLE || $5->type() == gamelang::CIRCLE || $5->type() == gamelang::RECTANGLE || 
         $5->type() == gamelang::PIXMAP){ gamelang::error(gamelang::INVALID_TYPE_FOR_FOR_STMT_EXPRESSION); }


      $$ = new For(initalizer, $5, incrementor, $9);
      
    }


//---------------------------------------------------------------------
print_statement: 
    T_PRINT T_LPAREN expression T_RPAREN {
      bool valid_type = $3->type() & (gamelang::INT|gamelang::DOUBLE|gamelang::STRING);
      if(valid_type ==false) gamelang::error(gamelang::INVALID_TYPE_FOR_PRINT_STMT_EXPRESSION);
      //const Constant* cnst = $3->evaluate();
      $$=new Print_statement($1, $3);
    }


//---------------------------------------------------------------------
exit_statement:
    T_EXIT T_LPAREN expression T_RPAREN {

      bool valid_type = $3->type() == gamelang::INT;
      if(valid_type ==false) gamelang::error(gamelang::EXIT_STATUS_MUST_BE_AN_INTEGER, gamelang::to_string($3->type()));
      $$ = new Exit($1, $3);
    }


//---------------------------------------------------------------------
assign_statement_or_empty:
    assign_statement
    | %empty


//---------------------------------------------------------------------
assign_statement:
    variable T_ASSIGN expression{
        
        gamelang::Type expression_type = $3->type();
        gamelang::Type variable_type = $1->type();

        //std::cerr << "expression: " << gamelang::to_string(expression_type) << " variable: " << gamelang::to_string(variable_type) << std::endl;
        if(expression_type == gamelang::DOUBLE && variable_type == gamelang::INT){ 
          gamelang::error(gamelang::ASSIGNMENT_TYPE_ERROR, gamelang::to_string(variable_type), gamelang::to_string(expression_type));
        }
        if(expression_type == gamelang::STRING && (variable_type == gamelang::INT || variable_type == gamelang::DOUBLE)){ 
          gamelang::error(gamelang::ASSIGNMENT_TYPE_ERROR, gamelang::to_string(variable_type), gamelang::to_string(expression_type));
        }
        if(expression_type == gamelang::CIRCLE && (variable_type == gamelang::STRING || variable_type == gamelang::DOUBLE || variable_type == gamelang::INT)){ 
          gamelang::error(gamelang::ASSIGNMENT_TYPE_ERROR, gamelang::to_string(variable_type), gamelang::to_string(expression_type));
        }
        if((variable_type == gamelang::CIRCLE || variable_type == gamelang::RECTANGLE || variable_type == gamelang::TRIANGLE || variable_type == gamelang::PIXMAP) && (variable_type != gamelang::STRING || variable_type != gamelang::DOUBLE || variable_type == gamelang::INT)){ 
          gamelang::error(gamelang::INVALID_LHS_OF_ASSIGNMENT, $1->symbol_name, gamelang::to_string(variable_type));
        }

        //if($3->evaluate() == nullptr){ std::cerr << "NULL IN ASSIGN_STATEMENT" << std::endl;}
         
         $$ = new Assign($1, $3);
    }
    | variable T_PLUS_ASSIGN expression { 
      
      gamelang::Type expression_type = $3->type();
      gamelang::Type variable_type = $1->type();
      Member_variable* member_var = dynamic_cast<Member_variable*>($1);
        std::string attribute_info;
        if(member_var != nullptr){
        attribute_info = member_var->full_name();  // symbol_name.attribute_name
        }else{
            attribute_info = $1->symbol_name;  // Only symbol_name if it's not a Member_variable
        }

      if(expression_type == gamelang::DOUBLE && variable_type == gamelang::INT){ 
        gamelang::error(gamelang::PLUS_ASSIGNMENT_TYPE_ERROR, gamelang::to_string(variable_type), gamelang::to_string(expression_type));
      }
      if(expression_type == gamelang::STRING && (variable_type == gamelang::INT || variable_type == gamelang::DOUBLE)){ 
        gamelang::error(gamelang::PLUS_ASSIGNMENT_TYPE_ERROR, gamelang::to_string(variable_type), gamelang::to_string(expression_type));
      }
      if(expression_type == gamelang::CIRCLE && (variable_type == gamelang::STRING || variable_type == gamelang::DOUBLE || variable_type == gamelang::INT)){ 
          gamelang::error(gamelang::PLUS_ASSIGNMENT_TYPE_ERROR, gamelang::to_string(variable_type), gamelang::to_string(expression_type));
      }
      if((variable_type == gamelang::CIRCLE || variable_type == gamelang::RECTANGLE || variable_type == gamelang::TRIANGLE || variable_type == gamelang::PIXMAP) && 
      (variable_type != gamelang::STRING || variable_type != gamelang::DOUBLE || variable_type == gamelang::INT)){ 
        gamelang::error(gamelang::INVALID_LHS_OF_PLUS_ASSIGNMENT, attribute_info, gamelang::to_string(variable_type));
      }
      
      $$ = new Assign_plus($1, $3); }
    | variable T_MINUS_ASSIGN expression { 
      gamelang::Type expression_type = $3->type();
      gamelang::Type variable_type = $1->type();

      if((expression_type == gamelang::DOUBLE || expression_type == gamelang::STRING || expression_type == gamelang::CIRCLE || expression_type == gamelang::TRIANGLE || 
          expression_type == gamelang::RECTANGLE || expression_type == gamelang::PIXMAP) 
          && variable_type == gamelang::INT){ 
        gamelang::error(gamelang::MINUS_ASSIGNMENT_TYPE_ERROR, gamelang::to_string(variable_type), gamelang::to_string(expression_type));
      }
      if((expression_type == gamelang::STRING || expression_type == gamelang::CIRCLE || expression_type == gamelang::TRIANGLE || 
          expression_type == gamelang::RECTANGLE || expression_type == gamelang::PIXMAP)  && (variable_type == gamelang::DOUBLE)){ 
        gamelang::error(gamelang::MINUS_ASSIGNMENT_TYPE_ERROR, gamelang::to_string(variable_type), gamelang::to_string(expression_type));
      }
      /*if(expression_type == gamelang::CIRCLE && (variable_type == gamelang::STRING || variable_type == gamelang::DOUBLE || variable_type == gamelang::INT)){ 
          gamelang::error(gamelang::MINUS_ASSIGNMENT_TYPE_ERROR, gamelang::to_string(variable_type), gamelang::to_string(expression_type));
      }*/
      if((variable_type == gamelang::CIRCLE || variable_type == gamelang::STRING || variable_type == gamelang::TRIANGLE || variable_type == gamelang::RECTANGLE || variable_type == gamelang::PIXMAP) && 
      (variable_type != gamelang::DOUBLE || variable_type == gamelang::INT)){ 
        //assert(false);
        Member_variable* member_var = dynamic_cast<Member_variable*>($1);
        std::string attribute_info;
        if(member_var != nullptr){
        attribute_info = member_var->full_name();  // symbol_name.attribute_name
        }else{
            attribute_info = $1->symbol_name;  // Only symbol_name if it's not a Member_variable
        }
            gamelang::error(gamelang::INVALID_LHS_OF_MINUS_ASSIGNMENT, attribute_info, gamelang::to_string(variable_type));
      }
      $$ = new Assign_minus($1, $3); }
    | variable T_PLUS_PLUS { 
      gamelang::Type variable_type = $1->type();
      if((variable_type != gamelang::INT)){ 
        Member_variable* member_var = dynamic_cast<Member_variable*>($1);
        std::string attribute_info;
        if(member_var != nullptr){
        attribute_info = member_var->full_name();  // symbol_name.attribute_name
        }else{
            attribute_info = $1->symbol_name;  // Only symbol_name if it's not a Member_variable
        }
        gamelang::error(gamelang::INVALID_LHS_OF_PLUS_PLUS, attribute_info, gamelang::to_string(variable_type));
      }
      $$ = new PlusPlus($1); }
    | variable T_MINUS_MINUS { 
      gamelang::Type variable_type = $1->type();
      

      std::string name = "";
      if((variable_type != gamelang::INT)){ 
        Member_variable* member_var = dynamic_cast<Member_variable*>($1);
        std::string attribute_info;
        if(member_var != nullptr){
        attribute_info = member_var->full_name();  // symbol_name.attribute_name
        }else{
            attribute_info = $1->symbol_name;  // Only symbol_name if it's not a Member_variable
        }
        gamelang::error(gamelang::INVALID_LHS_OF_MINUS_MINUS, attribute_info, gamelang::to_string(variable_type));
      }
      $$ = new MinusMinus($1); }


//---------------------------------------------------------------------
variable:
    T_ID { 
        Symbol* sym = sm.lookup(*$1); 
        if(sym != nullptr){  
            if(sym->get_count() != 0){
                    gamelang::error(gamelang::VARIABLE_IS_AN_ARRAY, *$1);
                    //break;
                }
            const std::string temp = *$1;           
            {$$ = new Variable(temp);};   
            break;
        }else{
            { $$ = new Variable("");};
            gamelang::error(gamelang::UNDECLARED_VARIABLE, *$1);
            
        }
    }  
    | T_ID T_LBRACKET expression T_RBRACKET{
        Symbol* sym = sm.lookup(*$1); 
        if($3->type() == gamelang::STRING || $3->type() == gamelang::DOUBLE || $3->type() == gamelang::CIRCLE || 
         $3->type() == gamelang::TRIANGLE || $3->type() == gamelang::RECTANGLE || $3->type() == gamelang::PIXMAP){
        //std::cerr << "IM NOT AN INT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" <<std:: endl;


        
        gamelang::error(gamelang::ARRAY_INDEX_MUST_BE_AN_INTEGER, *$1, to_string($3->type()));
        $$ = new Variable("");
        break;
      }
            if(sym != nullptr){
                if(sym->get_count() == 0){
                    gamelang::error(gamelang::VARIABLE_NOT_AN_ARRAY, *$1);
                    {$$= new Variable("");};
                    delete $3;
                    break;
                }
                
                const std::string temp = *$1;
                {$$ = new Variable(temp, $3);}; 
                break;
            }else{
                if(sm.defined_in_current_scope(*$1)){
                throw std::invalid_argument("prev declared var");
              }
                gamelang::error(gamelang::UNDECLARED_VARIABLE, *$1 + "[]");
                {$$= new Variable("");};
                delete $3;
                break;
            }
        }  
    | T_ID T_PERIOD T_ID{
        std::unique_ptr<std::string> d1($1);
        std::unique_ptr<std::string> d3($3);
        Symbol* sym=sm.lookup(*d1);
        if(sym==nullptr) {
          gamelang::error(gamelang::UNDECLARED_VARIABLE, *d1);
          $$=new Variable("");
          break;
        }
        if(sym->get_count() != 0) {
          gamelang::error(gamelang::VARIABLE_IS_AN_ARRAY, *d1);
          $$=new Variable("");
          break;
        }
        try { 
        std::unique_ptr<const Constant>(sym->as_constant(*d3)); }
        catch(gamelang::Type actual_type) {
          gamelang::error(gamelang::LHS_OF_PERIOD_MUST_BE_OBJECT, *d1);
          $$=new Variable("");
          break;
        }
        catch(std::out_of_range& oor) {
          gamelang::error(gamelang::UNDECLARED_MEMBER, *d1, *d3);
          $$=new Variable("");
          break;
        }
        $$=new Member_variable(*d1 , *d3);
      }   
    | T_ID T_LBRACKET expression T_RBRACKET T_PERIOD T_ID {
      Symbol* sym = sm.lookup(*$1); 
      std::unique_ptr<std::string> d1($1);
      std::unique_ptr<std::string> d6($6);


      if(sym == nullptr) {
          gamelang::error(gamelang::UNDECLARED_VARIABLE, *$1 + "[]");
          $$ = new Variable("");
          break;
      }  
      if(sym->get_count() == 0) {
        gamelang::error(gamelang::VARIABLE_NOT_AN_ARRAY, *$1);
        $$ = new Variable("");
        break;
      }      
      
      if($3->type() == gamelang::STRING || $3->type() == gamelang::DOUBLE || $3->type() == gamelang::CIRCLE || 
         $3->type() == gamelang::TRIANGLE || $3->type() == gamelang::RECTANGLE || $3->type() == gamelang::PIXMAP){
        //std::cerr << "IM NOT AN INT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" <<std:: endl;


        
        gamelang::error(gamelang::ARRAY_INDEX_MUST_BE_AN_INTEGER, *$1, to_string($3->type()));
        $$ = new Variable("");
        break;
      }
     
      try{
        std::unique_ptr<const Constant>(sym->as_constant(*d6));
      }catch(gamelang::Type actual_type){
          gamelang::error(gamelang::LHS_OF_PERIOD_MUST_BE_OBJECT, *d1);
          $$ = new Variable("");
          break;
      }catch(std::out_of_range& oor){
          gamelang::error(gamelang::UNDECLARED_MEMBER, *d1, *d6);
          $$ = new Variable("");
          break;
      } 
      $$ = new Member_variable(*d1, *d6, $3);
    }
      

//---------------------------------------------------------------------
expression: primary_expression {$$=$1;}

expression:
    expression T_OR expression { $$=Bin_op_check<Or, gamelang::OR>($1, $3, gamelang::INT|gamelang::DOUBLE); }
    | expression T_AND expression { $$=Bin_op_check<And, gamelang::AND>($1, $3, gamelang::INT|gamelang::DOUBLE); }
    | expression T_LESS_EQUAL expression { $$=Bin_op_check<LessEqual, gamelang::LESS_EQUAL>($1, $3, gamelang::INT|gamelang::DOUBLE|gamelang::STRING);}
    | expression T_GREATER_EQUAL  expression {$$=Bin_op_check<GreatEqual, gamelang::GREATER_EQUAL>($1, $3, gamelang::INT|gamelang::DOUBLE|gamelang::STRING);}
    | expression T_LESS expression {$$=Bin_op_check<Lesser, gamelang::LESS_THAN>($1, $3, gamelang::INT|gamelang::DOUBLE|gamelang::STRING);}
    | expression T_GREATER  expression {$$=Bin_op_check<Greater, gamelang::GREATER_THAN>($1, $3, gamelang::INT|gamelang::DOUBLE|gamelang::STRING);}
    | expression T_EQUAL expression {$$=Bin_op_check<Equal, gamelang::EQUAL>($1, $3, gamelang::INT|gamelang::DOUBLE|gamelang::STRING);}
    | expression T_NOT_EQUAL expression {$$=Bin_op_check<NotEqual, gamelang::NOT_EQUAL>($1, $3, gamelang::INT|gamelang::DOUBLE|gamelang::STRING);}
    | expression T_PLUS expression { $$=Bin_op_check<Add, gamelang::PLUS>($1, $3, gamelang::INT|gamelang::DOUBLE|gamelang::STRING); }
    | expression T_MINUS expression { $$=Bin_op_check<Sub, gamelang::MINUS>($1, $3, gamelang::INT|gamelang::DOUBLE);}
    | expression T_MULTIPLY expression { $$=Bin_op_check<Multiply, gamelang::MULTIPLY>($1, $3, gamelang::INT|gamelang::DOUBLE); }
    | expression T_DIVIDE expression { $$=Bin_op_check<Divide, gamelang::DIVIDE>($1, $3, gamelang::INT|gamelang::DOUBLE); }
    | expression T_MOD expression { $$=Bin_op_check<Mod, gamelang::MOD>($1, $3, gamelang::INT); }
    | T_MINUS  expression %prec NEGATION { $$=Uni_op_check<Neg, gamelang::UNARY_MINUS>($2, gamelang::INT|gamelang::DOUBLE);}
    | T_NOT  expression {$$=Uni_op_check<Not, gamelang::NOT>($2, gamelang::INT|gamelang::DOUBLE);}
    | expression T_NEAR expression
    | expression T_TOUCHES expression


primary_expression:
    T_SIN T_LPAREN expression T_RPAREN {$$=Uni_op_check<Sin, gamelang::SIN>($3, gamelang::INT|gamelang::DOUBLE); }
    | T_COS T_LPAREN expression T_RPAREN {$$=Uni_op_check<Cos, gamelang::COS>($3, gamelang::INT|gamelang::DOUBLE);}
    | T_TAN T_LPAREN expression T_RPAREN {$$=Uni_op_check<Tan, gamelang::TAN>($3, gamelang::INT|gamelang::DOUBLE);}
    | T_ASIN T_LPAREN expression T_RPAREN {$$=Uni_op_check<Asin, gamelang::ASIN>($3, gamelang::INT|gamelang::DOUBLE);}
    | T_ACOS T_LPAREN expression T_RPAREN {$$=Uni_op_check<Acos, gamelang::ACOS>($3, gamelang::INT|gamelang::DOUBLE);}
    | T_ATAN T_LPAREN expression T_RPAREN {$$=Uni_op_check<Atan, gamelang::ATAN>($3, gamelang::INT|gamelang::DOUBLE);}
    | T_SQRT T_LPAREN expression T_RPAREN {$$=Uni_op_check<Sqrt, gamelang::SQRT>($3, gamelang::INT|gamelang::DOUBLE);}
    | T_ABS T_LPAREN expression T_RPAREN {$$=Uni_op_check<Abs, gamelang::ABS>($3, gamelang::INT|gamelang::DOUBLE); }
    | T_FLOOR T_LPAREN expression T_RPAREN {$$=Uni_op_check<Floor, gamelang::FLOOR>($3, gamelang::INT|gamelang::DOUBLE);}
    | T_RANDOM T_LPAREN expression T_RPAREN { $$=Uni_op_check<Rand, gamelang::RANDOM>($3, gamelang::INT|gamelang::DOUBLE); }


//---------------------------------------------------------------------
primary_expression:
    T_LPAREN  expression T_RPAREN {$$ = $2; }
    | variable          { $$ = $1; }
    | T_INT_CONSTANT    { $$ = new Integer_constant($1); }
    | T_TRUE            { $$ = new Integer_constant(1); }
    | T_FALSE           { $$ = new Integer_constant(0); }
    | T_DOUBLE_CONSTANT { $$=new Double_constant($1); }
    | T_STRING_CONSTANT { $$=new String_constant(*$1); delete $1; } 
    ;
%%
